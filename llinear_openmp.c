/*mex llinear_openmp.c CFLAGS='\$CFLAGS -fopenmp -O3' LDFLAGS='\$LDFLAGS -fopenmp'*/#include <math.h>#include <stdio.h>#include <stdint.h>typedef uint16_t char16_t;#include "mex.h"#define max(a,b) (a > b) ? a : bvoid forward_elim(int, double **, int *);void solve(int, double **, int *, double * , double *);/*******************************************************/void forward_elim (int matrix_size, double **A, int *L){	int i,j,k, tempi, tempk;	double *S;	double xmult, smax, rmax, ratio; 	S = calloc((matrix_size+1), sizeof(double)); 	for (i = 1; i <= matrix_size; i++) 	{		L[i] = i;		smax = 0.0;		for (j = 1; j <= matrix_size; j++)			smax = max (smax, fabs(A[i][j]));		S[i] = smax; 	}	for (k = 1; k < matrix_size; k++)	{		rmax = 0.0;		for (i = k ; i <= matrix_size; i++)		{ 			tempi = L[i];			ratio = fabs(A[tempi][k]/ S[tempi]);			if (ratio > rmax) 			{				rmax = ratio;				j = i;			}		}		tempk = L[j];		L[j] = L[k];		L[k] = tempk;		for (i = k+1; i <= matrix_size; i++)		{ 			tempi = L[i];			xmult = A[tempi][k] /A[tempk][k];			A[tempi][k] = xmult;			for (j = k+1; j<= matrix_size; j++)				A[tempi][j] -= xmult * A[tempk][j];		}  	}}/* forward_elim *//**********************************************************/void solve (int matrix_size, double **A, int *L, double *B, double *X){	int i,j, k, tempi, tempk, tempn;	double sum;	for (k = 1; k < matrix_size ; k++)	{		tempk = L[k];		for (i = k+1; i <= matrix_size; i++)		{			tempi = L[i];						B[tempi] -= A[tempi][k] * B[tempk];		}	} 	tempn = L[matrix_size]; 	X[matrix_size] = B[tempn] / A[tempn][matrix_size]; 	for (i = matrix_size -1; i>= 1; i--) 	{  		tempi = L[i];		sum = B[tempi];		for (j = i+1; j <= matrix_size ; j++)			sum -= A[tempi][j] * X[j];		X[i] = sum / A[tempi][i];	}}double lfitlinear(double *xin, double *yin, double *x, const double *bw, const int n, const int p){	int i, j, k, matrix_size = p+1;	double K, Z, yout;	double **A, *t, *b;	int *L;	A = calloc((matrix_size+1),sizeof(double *));	for (j=0;j<=matrix_size;j++){		A[j] = calloc((matrix_size+1),sizeof(double));	}	t = calloc((matrix_size+1),sizeof(double));	b = calloc((matrix_size+1),sizeof(double));	L = calloc((matrix_size+1),sizeof(double));	for (i=0;i<n;i++){		/* check if i-th xin falls between (x-h,x+h) */		K = 1;		for (j=1;j<=p;j++){			Z = xin[j-1+i*p]-x[j-1];			if (fabs(Z)<bw[j-1]){				Z = Z/bw[j-1];				K *= 0.75*(1-Z*Z);			}			else{				K = 0;				break;			}		}		if (K==0)			continue;		A[1][1] += K; t[1] += K*yin[i];		for (k=2;k<=matrix_size;k++){			A[1][k] += K*(xin[k-2+i*p]-x[k-2]);			t[k] += K*(xin[k-2+i*p]-x[k-2])*yin[i];		}		for (j=2;j<=matrix_size;j++){			for (k=j;k<=matrix_size;k++){				A[j][k] += K*(xin[j-2+i*p]-x[j-2])*(xin[k-2+i*p]-x[k-2]);			}		}	}		for (j=1;j<=matrix_size;j++){		for (k=j;k<=matrix_size;k++)			A[k][j] = A[j][k];	}	for (j=2;j<=matrix_size;j++)		A[j][j] += 1e-8;	forward_elim(matrix_size,A,L);	solve(matrix_size,A,L,t,b);	yout = b[1];	for (j=0;j<=matrix_size;j++)		free(A[j]);	free(A);	free(t);	free(b);	free(L);	return yout;}void llinear(double *xin, double *yin, double *xout, double *yout, const double *bw, const int m, const int n, const int p){	int i, j;	double *x;	#pragma omp parallel private(i,x)	{		x = calloc(p,sizeof(double *));		#pragma omp for		for (i=0;i<m;i++)		{			for (j=0;j<p;j++){				x[j] = xout[j+i*p];			}			yout[i] = (double)lfitlinear(xin,yin,x,bw,n,p);		}		free(x);	}}/* --------------------------------------------------------------------------Gateway function for MATLABUsage in MATLAB: yhat = llineard(xin,yin,xout,bw);xin: input designs; p*n matrix (in fact, an p*n by 1 array)yin: input data points; n*1 arrayxout: grid points to estimate; p*m matrix (in fact, an p*m by 1 array)bw: bandwidth; p*1 array-------------------------------------------------------------------------- */void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]){			double *xin, *yin, *xout, *yout, *bw;	int m,n,p;	/* create a pointer to the real data in the input matrix */	xin = mxGetPr(prhs[0]);	/* get the value of the scalar input */	yin = mxGetPr(prhs[1]);	xout = mxGetPr(prhs[2]);	bw = mxGetPr(prhs[3]);	/* get dimensions of the input matrix */	p = mxGetM(prhs[0]); /* dimension of xin */	n = mxGetN(prhs[0]); /* length of xin */	m = mxGetN(prhs[2]); /* length of xout */	/* create the output matrix */	plhs[0] = mxCreateDoubleMatrix(m,1,mxREAL);	/* get a pointer to the real data in the output matrix */	yout = mxGetPr(plhs[0]);	/* call the computational routine */	llinear(xin,yin,xout,yout,bw,m,n,p);}